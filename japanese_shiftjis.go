package chardet

var shift_map = map[rune]int{
	0x82cc: 0x00,
	0x82a2: 0x01,
	0x82bd: 0x02,
	0x82c6: 0x03,
	0x82a9: 0x04,
	0x82c4: 0x05,
	0x82b5: 0x06,
	0x82c8: 0x07,
	0x82c9: 0x08,
	0x82c1: 0x09,
	0x82a4: 0x0a,
	0x82cd: 0x0b,
	0x82aa: 0x0c,
	0x82c5: 0x0d,
	0x82e9: 0x0e,
	0x82f0: 0x0f,
	0x82f1: 0x10,
	0x82b1: 0x11,
	0x82e7: 0x12,
	0x82bb: 0x13,
	0x82a0: 0x14,
	0x82ea: 0x15,
	0x82e0: 0x16,
	0x82dc: 0x17,
	0x8393: 0x18,
	0x838d: 0x19,
	0x8358: 0x1a,
	0x8367: 0x1b,
	0x838b: 0x1c,
	0x838c: 0x1d,
	0x82be: 0x1e,
	0x82e6: 0x1f,
	0x82d9: 0x20,
	0x82e2: 0x21,
	0x82e8: 0x22,
	0x82ab: 0x23,
	0x82a6: 0x24,
	0x82af: 0x25,
	0x82ad: 0x26,
	0x82a8: 0x27,
	0x82dd: 0x28,
	0x82e5: 0x29,
	0x82e1: 0x2a,
	0x82c2: 0x2b,
	0x82bf: 0x2c,
	0x82cf: 0x2d,
	0x82b6: 0x2e,
	0x82c7: 0x2f,
	0x82b8: 0x30,
	0x82b7: 0x31,
	0x82b2: 0x32,
	0x82d0: 0x33,
	0x82eb: 0x34,
	0x82ce: 0x35,
	0x82b0: 0x36,
	0x82b9: 0x37,
	0x8368: 0x38,
	0x834e: 0x39,
	0x834f: 0x3a,
	0x8360: 0x3b,
	0x815b: 0x3c,
	0x8343: 0x3d,
	0x835e: 0x3e,
	0x8365: 0x3f,
	0x838a: 0x40,
	0x8389: 0x41,
	0x8354: 0x42,
	0x837e: 0x43,
	0x8381: 0x44,
	0x8372: 0x45,
	0x8352: 0x46,
	0x8378: 0x47,
	0x8349: 0x48,
	0x836d: 0x49,
}

// shift-jis (japanese)
// [\x00-\x7F]
// [\xA1-\xDF]
// [\x81-\x9F\xE0-\xEF][\x40-\x7E\x80-\xFC]
type shiftJIS struct {
	byte
	last int
	curr rune
	hold [30]struct {
		num int
		sub map[int]int
	}
}

func newShiftJIS() *shiftJIS {
	ans := &shiftJIS{}
	ans.last = -1
	for i := 0; i < 30; i++ {
		m := map[int]int{}
		for k, _ := range freq_sub[i] {
			m[k] = 0
		}
		ans.hold[i].sub = m
	}
	return ans
}

func (s shiftJIS) String() string {
	return "shift-jis"
}

func (s *shiftJIS) Feed(x byte) bool {
	defer func() {
		if i, ok := shift_map[s.curr]; ok {
			if i < 30 {
				s.hold[i].num++
			}
			if s.last >= 0 {
				m := s.hold[s.last].sub
				if _, ok := m[i]; ok {
					m[i]++
				}
			}
			if i < 30 {
				s.last = i
			} else {
				s.last = -1
			}
		} else {
			s.last = -1
		}
	}()
	if s.byte == 0 {
		if (x >= 0x00 && x <= 0x7F) || (x >= 0xA1 && x <= 0xDF) {
			s.curr = rune(x)
			return true
		}
		if (x >= 0x81 && x <= 0x9F) || (x >= 0xE0 && x <= 0xEF) {
			s.byte = 1
			s.curr = rune(x) << 8
			return true
		}
	} else {
		if (x >= 0x40 && x <= 0x7E) || (x >= 0x80 && x <= 0xFC) {
			s.byte = 0
			s.curr |= rune(x)
			return true
		}
	}
	return false
}

func (s *shiftJIS) Priority() float64 {
	sub := func(p map[int]int, r map[int]float64) float64 {
		s, f := 0, 0.0
		for _, x := range p {
			s += x
		}
		if s == 0 {
			return 0
		}
		for i, x := range p {
			k := float64(x)/float64(s)*100 - r[i]
			if k >= 0 {
				f += k
			} else {
				f -= k
			}
		}
		return 1 - f/100
	}
	d := 0
	for _, x := range s.hold {
		d += x.num
	}
	if d == 0 {
		return 0
	}
	p, f := 0.0, 0.0
	for i, x := range s.hold {
		k := float64(x.num)/float64(d)*100 - freq_dad[i]
		if k >= 0 {
			f += k
		} else {
			f -= k
		}
		p += sub(x.sub, freq_sub[i])
	}
	return (p + 1 - f/100) / 31
}
